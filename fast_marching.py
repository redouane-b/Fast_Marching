# -*- coding: utf-8 -*-
"""Fast_Marching.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1RCvwATp3rCS3oL64oTqosICjdpcuPCfz
"""

import numpy as np

"""## Création des matrices"""

# F=np.zeros((110,112))
# F=np.ones_like(F)
F=FL

Statut=-1*np.ones_like(F)
# Statut=-1 (Far away)
# Statut=0  (Frozen points)
# Statut=1  (Narrow band)

T=float('inf')*np.ones_like(F)
limits=T.shape

Narrow_Band=[]

"""##Définition de la fonction voisins qui pour un point donné, donne tous ses voisins directes"""

#seulement direction propagation du front
def voisins(Point):
  i=Point[0]
  j=Point[1]

  if i==limits[0]-1:
    if j==0:
      return [[i-1,j,T[i-1][j]],[i,j+1,T[i][j+1]]]
    if j==limits[1]-1:
      return [[i-1,j,T[i-1][j]],[i,j-1,T[i][j-1]]]
    else:
      return [[i-1,j,T[i-1][j]],[i,j-1,T[i][j-1]],[i,j+1,T[i][j+1]]]


  if i==0:
    if j==0:
      return [[i+1,j,T[i+1][j]],[i,j+1,T[i][j+1]]]
    if j==limits[1]-1:
      return [[i+1,j,T[i+1][j]],[i,j-1,T[i][j-1]]]
    else:
      return [[i+1,j,T[i+1][j]],[i,j+1,T[i][j+1]],[i,j-1,T[i][j-1]]]

  if j==limits[1]-1:
    if i==0:
      return [[i+1,j,T[i+1][j]],[i,j-1,T[i][j-1]]]
    if i==limits[0]-1:
      return [[i-1,j,T[i-1][j]],[i,j-1,T[i][j-1]]]
    else:
      return [[i-1,j,T[i-1][j]],[i,j-1,T[i][j-1]],[i+1,j,T[i+1][j]]]

  if j==0:
    if i==0:
      return [[i+1,j,T[i+1][j]],[i,j+1,T[i][j+1]]]
    if i==limits[0]-1:
      return [[i-1,j,T[i-1][j]],[i,j+1,T[i][j+1]]]
    else:
      return [[i+1,j,T[i+1][j]],[i,j+1,T[i][j+1]],[i-1,j,T[i-1][j]]]

  else:
      return [[i,j-1,T[i][j-1]],[i+1,j,T[i+1][j]],[i-1,j,T[i-1][j]],[i,j+1,T[i][j+1]]]

"""## Définition de fonctions qui change le statut d'un point donné"""

def far_to_neighbour(c):
  Statut[c[0],c[1]]=1

def neighbour_to_frozen(c):
  Statut[c[0],c[1]]=0

"""## Fonction d'initialisation """

def initialisation(Point_init):
  i0=Point_init[0]
  j0=Point_init[1]
  T[i0][j0]=0
  Statut[i0][j0]=0

"""## Fonctions test du statut d'un point"""

def isFrozen(Point):
  i=Point[0]
  j=Point[1]
  return Statut[i][j]==0

def isNeighbour(Point):
  i=Point[0]
  j=Point[1]
  return Statut[i][j]==1

"""## Première itération de l'algorithme Fast Marching"""

# def Premiere_iteration(Point_init):
#   global Narrow_Band
#   Narrow_Band+=voisins(Point_init)
#
#   for c in Narrow_Band:
#     c[2]=updateT(c)
#     far_to_neighbour(c)
#   return Narrow_Band

"""## Fonction qui met à jour le temps d'arrivée T"""

def updateT(Point):
    i=Point[0]
    j=Point[1]

    if i==limits[0]-1:
      Ta=T[i-1][j]
    elif i==0:
      Ta=T[i+1][j]
    else:
      Ta=min(T[i-1][j],T[i+1][j])

    if j==limits[1]-1:
      Tb=T[i][j-1]
    elif j==0:
      Tb=T[i][j+1]
    else:
      Tb=min(T[i][j-1],T[i][j+1])

    if abs(Ta-Tb)<F[i][j]:
      t=(Ta+Tb+np.sqrt(2*(F[i][j])**2-(Ta-Tb)**2))/2
    else:
      t=F[i][j]+min(Ta,Tb)

    T[i][j]=min(t,T[i][j])
    Point[2]=T[i][j]
    return T[i][j]

"""## Fonction itération de l'algorithme Fast Marching"""

def iterate(Narrow_Band):

  while Narrow_Band!=[]:

  #trier narrow band par rapport a la 3eme valeur
    Narrow_Band=sorted(Narrow_Band,key=third)
    # print()
    # print(Narrow_Band)

  #Prendre le point avec le plus petit T et l'enlever
    Point=Narrow_Band.pop(0)
    neighbour_to_frozen(Point)
    # print(Point)
    # print()
  #Calculer T pour ses voisins si non Frozen
    Neighbours=voisins(Point)
    if Neighbours!=None:
      for voisin in Neighbours:
        if not isFrozen(voisin):
          updateT(voisin)
          # print(voisin)


  #Ajouter ses voisins avec leur T sur Narrow Band
          if not isNeighbour(voisin):
            Narrow_Band.append(voisin)
            far_to_neighbour(voisin)
          else:
            for c in Narrow_Band:
              if voisin[0]==c[0] and voisin[1]==c[1]:
                c=voisin

"""clef pour le try"""
def third(el):
  return(el[2])
"""## Fonction principale"""


def Fast_Marching():
  initialisation(Point_init)
  # Premiere_iteration(Point_init)
  Narrow_Band=[Point_init]
  iterate(Narrow_Band)

"""## Test sur un exemple de distance avec point intiale (25,10)"""

Point_init=[60,60,0]
Fast_Marching()

"""## Affichage du temps d'arrivée des points"""

import pandas as pd
pd.DataFrame(T)

"""## Affichage du temps d'arrivée"""

import matplotlib.pyplot as plt

plt.imshow(T, cmap='hot', interpolation='nearest')
plt.show()